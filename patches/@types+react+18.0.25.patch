diff --git a/node_modules/@types/react/index.d.ts b/node_modules/@types/react/index.d.ts
index 2876d26..5a24a78 100755
--- a/node_modules/@types/react/index.d.ts
+++ b/node_modules/@types/react/index.d.ts
@@ -105,20 +105,20 @@ declare namespace React {
      */
     type ElementRef<
         C extends
-            | ForwardRefExoticComponent<any>
-            | { new (props: any): Component<any> }
-            | ((props: any, context?: any) => ReactElement | null)
-            | keyof JSX.IntrinsicElements
+        | ForwardRefExoticComponent<any>
+        | { new(props: any): Component<any> }
+        | ((props: any, context?: any) => ReactElement | null)
+        | keyof JSX.IntrinsicElements
     > =
         // need to check first if `ref` is a valid prop for ts@3.0
         // otherwise it will infer `{}` instead of `never`
         "ref" extends keyof ComponentPropsWithRef<C>
-            ? NonNullable<ComponentPropsWithRef<C>["ref"]> extends Ref<
-                infer Instance
-            >
-                ? Instance
-                : never
-            : never;
+        ? NonNullable<ComponentPropsWithRef<C>["ref"]> extends Ref<
+            infer Instance
+        >
+        ? Instance
+        : never
+        : never;
 
     type ComponentState = any;
 
@@ -204,7 +204,7 @@ declare namespace React {
     type DOMFactory<P extends DOMAttributes<T>, T extends Element> =
         (props?: ClassAttributes<T> & P | null, ...children: ReactNode[]) => DOMElement<P, T>;
 
-    interface HTMLFactory<T extends HTMLElement> extends DetailedHTMLFactory<AllHTMLAttributes<T>, T> {}
+    interface HTMLFactory<T extends HTMLElement> extends DetailedHTMLFactory<AllHTMLAttributes<T>, T> { }
 
     interface DetailedHTMLFactory<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMFactory<P, T> {
         (props?: ClassAttributes<T> & P | null, ...children: ReactNode[]): DetailedReactHTMLElement<P, T>;
@@ -226,8 +226,8 @@ declare namespace React {
     /**
      * @deprecated Use either `ReactNode[]` if you need an array or `Iterable<ReactNode>` if its passed to a host component.
      */
-    interface ReactNodeArray extends ReadonlyArray<ReactNode> {}
-    type ReactFragment = Iterable<ReactNode>;
+    interface ReactNodeArray extends ReadonlyArray<ReactNode> { }
+    type ReactFragment = {} | Iterable<ReactNode>;
     type ReactNode = ReactElement | string | number | ReactFragment | ReactPortal | boolean | null | undefined;
 
     //
@@ -348,7 +348,7 @@ declare namespace React {
         /**
          * **NOTE**: Exotic components are not callable.
          */
-        (props: P): (ReactElement|null);
+        (props: P): (ReactElement | null);
         readonly $$typeof: symbol;
     }
 
@@ -559,7 +559,7 @@ declare namespace React {
     }
 
     interface ComponentClass<P = {}, S = ComponentState> extends StaticLifecycle<P, S> {
-        new (props: P, context?: any): Component<P, S>;
+        new(props: P, context?: any): Component<P, S>;
         propTypes?: WeakValidationMap<P> | undefined;
         contextType?: Context<any> | undefined;
         contextTypes?: ValidationMap<any> | undefined;
@@ -569,7 +569,7 @@ declare namespace React {
     }
 
     interface ClassicComponentClass<P = {}> extends ComponentClass<P> {
-        new (props: P, context?: any): ClassicComponent<P, ComponentState>;
+        new(props: P, context?: any): ClassicComponent<P, ComponentState>;
         getDefaultProps?(): P;
     }
 
@@ -790,12 +790,12 @@ declare namespace React {
     type PropsWithRef<P> =
         // Just "P extends { ref?: infer R }" looks sufficient, but R will infer as {} if P is {}.
         'ref' extends keyof P
-            ? P extends { ref?: infer R | undefined }
-                ? string extends R
-                    ? PropsWithoutRef<P> & { ref?: Exclude<R, string> | undefined }
-                    : P
-                : P
-            : P;
+        ? P extends { ref?: infer R | undefined }
+        ? string extends R
+        ? PropsWithoutRef<P> & { ref?: Exclude<R, string> | undefined }
+        : P
+        : P
+        : P;
 
     type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined };
 
@@ -805,14 +805,14 @@ declare namespace React {
      */
     type ComponentProps<T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>> =
         T extends JSXElementConstructor<infer P>
-            ? P
-            : T extends keyof JSX.IntrinsicElements
-                ? JSX.IntrinsicElements[T]
-                : {};
+        ? P
+        : T extends keyof JSX.IntrinsicElements
+        ? JSX.IntrinsicElements[T]
+        : {};
     type ComponentPropsWithRef<T extends ElementType> =
         T extends (new (props: infer P) => Component<any, any>)
-            ? PropsWithoutRef<P> & RefAttributes<InstanceType<T>>
-            : PropsWithRef<ComponentProps<T>>;
+        ? PropsWithoutRef<P> & RefAttributes<InstanceType<T>>
+        : PropsWithRef<ComponentProps<T>>;
     type ComponentPropsWithoutRef<T extends ElementType> =
         PropsWithoutRef<ComponentProps<T>>;
 
@@ -821,8 +821,8 @@ declare namespace React {
     >
         ? Method
         : ComponentPropsWithRef<T> extends RefAttributes<infer Method>
-            ? Method
-            : never;
+        ? Method
+        : never;
 
     // will show `Memo(${Component.displayName || Component.name})` in devtools by default,
     // but can be given its own specific name
@@ -1020,7 +1020,7 @@ declare namespace React {
      * @version 16.8.0
      * @see https://reactjs.org/docs/hooks-reference.html#useref
      */
-    function useRef<T>(initialValue: T|null): RefObject<T>;
+    function useRef<T>(initialValue: T | null): RefObject<T>;
     // convenience overload for potentially undefined initialValue / call with 0 arguments
     // has a default to stop it from defaulting to {} instead
     /**
@@ -1068,7 +1068,7 @@ declare namespace React {
      * @version 16.8.0
      * @see https://reactjs.org/docs/hooks-reference.html#useimperativehandle
      */
-    function useImperativeHandle<T, R extends T>(ref: Ref<T>|undefined, init: () => R, deps?: DependencyList): void;
+    function useImperativeHandle<T, R extends T>(ref: Ref<T> | undefined, init: () => R, deps?: DependencyList): void;
     // I made 'inputs' required here and in useMemo as there's no point to memoizing without the memoization key
     // useCallback(X) is identical to just using X, useMemo(() => Y) is identical to just using Y.
     /**
@@ -1163,7 +1163,7 @@ declare namespace React {
      *
      * @see https://github.com/facebook/react/pull/21913
      */
-     export function useInsertionEffect(effect: EffectCallback, deps?: DependencyList): void;
+    export function useInsertionEffect(effect: EffectCallback, deps?: DependencyList): void;
 
     /**
      * @param subscribe
@@ -1207,7 +1207,7 @@ declare namespace React {
      * This might be a child element to the element on which the event listener is registered.
      * If you thought this should be `EventTarget & T`, see https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682
      */
-    interface SyntheticEvent<T = Element, E = Event> extends BaseSyntheticEvent<E, EventTarget & T, EventTarget> {}
+    interface SyntheticEvent<T = Element, E = Event> extends BaseSyntheticEvent<E, EventTarget & T, EventTarget> { }
 
     interface ClipboardEvent<T = Element> extends SyntheticEvent<T, NativeClipboardEvent> {
         clipboardData: DataTransfer;
@@ -2053,7 +2053,7 @@ declare namespace React {
         referrerPolicy?: HTMLAttributeReferrerPolicy | undefined;
     }
 
-    interface AudioHTMLAttributes<T> extends MediaHTMLAttributes<T> {}
+    interface AudioHTMLAttributes<T> extends MediaHTMLAttributes<T> { }
 
     interface AreaHTMLAttributes<T> extends HTMLAttributes<T> {
         alt?: string | undefined;
@@ -2120,8 +2120,8 @@ declare namespace React {
     }
 
     interface DialogHTMLAttributes<T> extends HTMLAttributes<T> {
-        onCancel?: ReactEventHandler<T> |  undefined;
-        onClose?: ReactEventHandler<T> |  undefined;
+        onCancel?: ReactEventHandler<T> | undefined;
+        onClose?: ReactEventHandler<T> | undefined;
         open?: boolean | undefined;
     }
 
@@ -2995,10 +2995,10 @@ declare namespace React {
 
     type WeakValidationMap<T> = {
         [K in keyof T]?: null extends T[K]
-            ? Validator<T[K] | null | undefined>
-            : undefined extends T[K]
-            ? Validator<T[K] | null | undefined>
-            : Validator<T[K]>
+        ? Validator<T[K] | null | undefined>
+        : undefined extends T[K]
+        ? Validator<T[K] | null | undefined>
+        : Validator<T[K]>
     };
 
     interface ReactPropTypes {
@@ -3087,17 +3087,17 @@ type NotExactlyAnyPropertyKeys<T> = Exclude<keyof T, ExactlyAnyPropertyKeys<T>>;
 type MergePropTypes<P, T> =
     // Distribute over P in case it is a union type
     P extends any
-        // If props is type any, use propTypes definitions
-        ? IsExactlyAny<P> extends true ? T :
-            // If declared props have indexed properties, ignore inferred props entirely as keyof gets widened
-            string extends keyof P ? P :
-                // Prefer declared types which are not exactly any
-                & Pick<P, NotExactlyAnyPropertyKeys<P>>
-                // For props which are exactly any, use the type inferred from propTypes if present
-                & Pick<T, Exclude<keyof T, NotExactlyAnyPropertyKeys<P>>>
-                // Keep leftover props not specified in propTypes
-                & Pick<P, Exclude<keyof P, keyof T>>
-        : never;
+    // If props is type any, use propTypes definitions
+    ? IsExactlyAny<P> extends true ? T :
+    // If declared props have indexed properties, ignore inferred props entirely as keyof gets widened
+    string extends keyof P ? P :
+    // Prefer declared types which are not exactly any
+    & Pick<P, NotExactlyAnyPropertyKeys<P>>
+    // For props which are exactly any, use the type inferred from propTypes if present
+    & Pick<T, Exclude<keyof T, NotExactlyAnyPropertyKeys<P>>>
+    // Keep leftover props not specified in propTypes
+    & Pick<P, Exclude<keyof P, keyof T>>
+    : never;
 
 type InexactPartial<T> = { [K in keyof T]?: T[K] | undefined };
 
@@ -3107,18 +3107,18 @@ type InexactPartial<T> = { [K in keyof T]?: T[K] | undefined };
 // Wrap in an outer-level conditional type to allow distribution over props that are unions
 type Defaultize<P, D> = P extends any
     ? string extends keyof P ? P :
-        & Pick<P, Exclude<keyof P, keyof D>>
-        & InexactPartial<Pick<P, Extract<keyof P, keyof D>>>
-        & InexactPartial<Pick<D, Exclude<keyof D, keyof P>>>
+    & Pick<P, Exclude<keyof P, keyof D>>
+    & InexactPartial<Pick<P, Extract<keyof P, keyof D>>>
+    & InexactPartial<Pick<D, Exclude<keyof D, keyof P>>>
     : never;
 
 type ReactManagedAttributes<C, P> = C extends { propTypes: infer T; defaultProps: infer D; }
     ? Defaultize<MergePropTypes<P, PropTypes.InferProps<T>>, D>
     : C extends { propTypes: infer T; }
-        ? MergePropTypes<P, PropTypes.InferProps<T>>
-        : C extends { defaultProps: infer D; }
-            ? Defaultize<P, D>
-            : P;
+    ? MergePropTypes<P, PropTypes.InferProps<T>>
+    : C extends { defaultProps: infer D; }
+    ? Defaultize<P, D>
+    : P;
 
 declare global {
     namespace JSX {
@@ -3133,8 +3133,8 @@ declare global {
         // let's assume it's reasonable to do a single React.lazy() around a single React.memo() / vice-versa
         type LibraryManagedAttributes<C, P> = C extends React.MemoExoticComponent<infer T> | React.LazyExoticComponent<infer T>
             ? T extends React.MemoExoticComponent<infer U> | React.LazyExoticComponent<infer U>
-                ? ReactManagedAttributes<U, P>
-                : ReactManagedAttributes<T, P>
+            ? ReactManagedAttributes<U, P>
+            : ReactManagedAttributes<T, P>
             : ReactManagedAttributes<C, P>;
 
         interface IntrinsicAttributes extends React.Attributes { }
